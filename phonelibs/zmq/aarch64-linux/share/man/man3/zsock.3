'\" t
.\"     Title: zsock
.\"    Author: [see the "AUTHORS" section]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 12/31/2016
.\"    Manual: CZMQ Manual
.\"    Source: CZMQ 4.0.2
.\"  Language: English
.\"
.TH "ZSOCK" "3" "12/31/2016" "CZMQ 4\&.0\&.2" "CZMQ Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
zsock \- high\-level socket API that hides libzmq contexts and sockets
.SH "SYNOPSIS"
.sp
.nf
//  This is a stable class, and may not change except for emergencies\&. It
//  is provided in stable builds\&.
//  This class has draft methods, which may change over time\&. They are not
//  in stable releases, by default\&. Use \-\-enable\-drafts to enable\&.
//  Create a new socket\&. Returns the new socket, or NULL if the new socket
//  could not be created\&. Note that the symbol zsock_new (and other
//  constructors/destructors for zsock) are redirected to the *_checked
//  variant, enabling intelligent socket leak detection\&. This can have
//  performance implications if you use a LOT of sockets\&. To turn off this
//  redirection behaviour, define ZSOCK_NOCHECK\&.
CZMQ_EXPORT zsock_t *
    zsock_new (int type);

//  Create a PUB socket\&. Default action is bind\&.
CZMQ_EXPORT zsock_t *
    zsock_new_pub (const char *endpoint);

//  Create a SUB socket, and optionally subscribe to some prefix string\&. Default
//  action is connect\&.
CZMQ_EXPORT zsock_t *
    zsock_new_sub (const char *endpoint, const char *subscribe);

//  Create a REQ socket\&. Default action is connect\&.
CZMQ_EXPORT zsock_t *
    zsock_new_req (const char *endpoint);

//  Create a REP socket\&. Default action is bind\&.
CZMQ_EXPORT zsock_t *
    zsock_new_rep (const char *endpoint);

//  Create a DEALER socket\&. Default action is connect\&.
CZMQ_EXPORT zsock_t *
    zsock_new_dealer (const char *endpoint);

//  Create a ROUTER socket\&. Default action is bind\&.
CZMQ_EXPORT zsock_t *
    zsock_new_router (const char *endpoint);

//  Create a PUSH socket\&. Default action is connect\&.
CZMQ_EXPORT zsock_t *
    zsock_new_push (const char *endpoint);

//  Create a PULL socket\&. Default action is bind\&.
CZMQ_EXPORT zsock_t *
    zsock_new_pull (const char *endpoint);

//  Create an XPUB socket\&. Default action is bind\&.
CZMQ_EXPORT zsock_t *
    zsock_new_xpub (const char *endpoint);

//  Create an XSUB socket\&. Default action is connect\&.
CZMQ_EXPORT zsock_t *
    zsock_new_xsub (const char *endpoint);

//  Create a PAIR socket\&. Default action is connect\&.
CZMQ_EXPORT zsock_t *
    zsock_new_pair (const char *endpoint);

//  Create a STREAM socket\&. Default action is connect\&.
CZMQ_EXPORT zsock_t *
    zsock_new_stream (const char *endpoint);

//  Destroy the socket\&. You must use this for any socket created via the
//  zsock_new method\&.
CZMQ_EXPORT void
    zsock_destroy (zsock_t **self_p);

//  Bind a socket to a formatted endpoint\&. For tcp:// endpoints, supports
//  ephemeral ports, if you specify the port number as "*"\&. By default
//  zsock uses the IANA designated range from C000 (49152) to FFFF (65535)\&.
//  To override this range, follow the "*" with "[first\-last]"\&. Either or
//  both first and last may be empty\&. To bind to a random port within the
//  range, use "!" in place of "*"\&.
//
//  Examples:
//      tcp://127\&.0\&.0\&.1:*           bind to first free port from C000 up
//      tcp://127\&.0\&.0\&.1:!           bind to random port from C000 to FFFF
//      tcp://127\&.0\&.0\&.1:*[60000\-]   bind to first free port from 60000 up
//      tcp://127\&.0\&.0\&.1:![\-60000]   bind to random port from C000 to 60000
//      tcp://127\&.0\&.0\&.1:![55000\-55999]
//                                  bind to random port from 55000 to 55999
//
//  On success, returns the actual port number used, for tcp:// endpoints,
//  and 0 for other transports\&. On failure, returns \-1\&. Note that when using
//  ephemeral ports, a port may be reused by different services without
//  clients being aware\&. Protocols that run on ephemeral ports should take
//  this into account\&.
CZMQ_EXPORT int
    zsock_bind (zsock_t *self, const char *format, \&.\&.\&.) CHECK_PRINTF (2);

//  Returns last bound endpoint, if any\&.
CZMQ_EXPORT const char *
    zsock_endpoint (zsock_t *self);

//  Unbind a socket from a formatted endpoint\&.
//  Returns 0 if OK, \-1 if the endpoint was invalid or the function
//  isn\*(Aqt supported\&.
CZMQ_EXPORT int
    zsock_unbind (zsock_t *self, const char *format, \&.\&.\&.) CHECK_PRINTF (2);

//  Connect a socket to a formatted endpoint
//  Returns 0 if OK, \-1 if the endpoint was invalid\&.
CZMQ_EXPORT int
    zsock_connect (zsock_t *self, const char *format, \&.\&.\&.) CHECK_PRINTF (2);

//  Disconnect a socket from a formatted endpoint
//  Returns 0 if OK, \-1 if the endpoint was invalid or the function
//  isn\*(Aqt supported\&.
CZMQ_EXPORT int
    zsock_disconnect (zsock_t *self, const char *format, \&.\&.\&.) CHECK_PRINTF (2);

//  Attach a socket to zero or more endpoints\&. If endpoints is not null,
//  parses as list of ZeroMQ endpoints, separated by commas, and prefixed by
//  \*(Aq@\*(Aq (to bind the socket) or \*(Aq>\*(Aq (to connect the socket)\&. Returns 0 if all
//  endpoints were valid, or \-1 if there was a syntax error\&. If the endpoint
//  does not start with \*(Aq@\*(Aq or \*(Aq>\*(Aq, the serverish argument defines whether
//  it is used to bind (serverish = true) or connect (serverish = false)\&.
CZMQ_EXPORT int
    zsock_attach (zsock_t *self, const char *endpoints, bool serverish);

//  Returns socket type as printable constant string\&.
CZMQ_EXPORT const char *
    zsock_type_str (zsock_t *self);

//  Send a \*(Aqpicture\*(Aq message to the socket (or actor)\&. The picture is a
//  string that defines the type of each frame\&. This makes it easy to send
//  a complex multiframe message in one call\&. The picture can contain any
//  of these characters, each corresponding to one or two arguments:
//
//      i = int (signed)
//      1 = uint8_t
//      2 = uint16_t
//      4 = uint32_t
//      8 = uint64_t
//      s = char *
//      b = byte *, size_t (2 arguments)
//      c = zchunk_t *
//      f = zframe_t *
//      h = zhashx_t *
//      U = zuuid_t *
//      p = void * (sends the pointer value, only meaningful over inproc)
//      m = zmsg_t * (sends all frames in the zmsg)
//      z = sends zero\-sized frame (0 arguments)
//      u = uint (deprecated)
//
//  Note that s, b, c, and f are encoded the same way and the choice is
//  offered as a convenience to the sender, which may or may not already
//  have data in a zchunk or zframe\&. Does not change or take ownership of
//  any arguments\&. Returns 0 if successful, \-1 if sending failed for any
//  reason\&.
CZMQ_EXPORT int
    zsock_send (void *self, const char *picture, \&.\&.\&.);

//  Send a \*(Aqpicture\*(Aq message to the socket (or actor)\&. This is a va_list
//  version of zsock_send (), so please consult its documentation for the
//  details\&.
CZMQ_EXPORT int
    zsock_vsend (void *self, const char *picture, va_list argptr);

//  Receive a \*(Aqpicture\*(Aq message to the socket (or actor)\&. See zsock_send for
//  the format and meaning of the picture\&. Returns the picture elements into
//  a series of pointers as provided by the caller:
//
//      i = int * (stores signed integer)
//      4 = uint32_t * (stores 32\-bit unsigned integer)
//      8 = uint64_t * (stores 64\-bit unsigned integer)
//      s = char ** (allocates new string)
//      b = byte **, size_t * (2 arguments) (allocates memory)
//      c = zchunk_t ** (creates zchunk)
//      f = zframe_t ** (creates zframe)
//      U = zuuid_t * (creates a zuuid with the data)
//      h = zhashx_t ** (creates zhashx)
//      p = void ** (stores pointer)
//      m = zmsg_t ** (creates a zmsg with the remaing frames)
//      z = null, asserts empty frame (0 arguments)
//      u = uint * (stores unsigned integer, deprecated)
//
//  Note that zsock_recv creates the returned objects, and the caller must
//  destroy them when finished with them\&. The supplied pointers do not need
//  to be initialized\&. Returns 0 if successful, or \-1 if it failed to recv
//  a message, in which case the pointers are not modified\&. When message
//  frames are truncated (a short message), sets return values to zero/null\&.
//  If an argument pointer is NULL, does not store any value (skips it)\&.
//  An \*(Aqn\*(Aq picture matches an empty frame; if the message does not match,
//  the method will return \-1\&.
CZMQ_EXPORT int
    zsock_recv (void *self, const char *picture, \&.\&.\&.);

//  Receive a \*(Aqpicture\*(Aq message from the socket (or actor)\&. This is a
//  va_list version of zsock_recv (), so please consult its documentation
//  for the details\&.
CZMQ_EXPORT int
    zsock_vrecv (void *self, const char *picture, va_list argptr);

//  Send a binary encoded \*(Aqpicture\*(Aq message to the socket (or actor)\&. This
//  method is similar to zsock_send, except the arguments are encoded in a
//  binary format that is compatible with zproto, and is designed to reduce
//  memory allocations\&. The pattern argument is a string that defines the
//  type of each argument\&. Supports these argument types:
//
//   pattern    C type                  zproto type:
//      1       uint8_t                 type = "number" size = "1"
//      2       uint16_t                type = "number" size = "2"
//      4       uint32_t                type = "number" size = "3"
//      8       uint64_t                type = "number" size = "4"
//      s       char *, 0\-255 chars     type = "string"
//      S       char *, 0\-2^32\-1 chars  type = "longstr"
//      c       zchunk_t *              type = "chunk"
//      f       zframe_t *              type = "frame"
//      u       zuuid_t *               type = "uuid"
//      m       zmsg_t *                type = "msg"
//      p       void *, sends pointer value, only over inproc
//
//  Does not change or take ownership of any arguments\&. Returns 0 if
//  successful, \-1 if sending failed for any reason\&.
CZMQ_EXPORT int
    zsock_bsend (void *self, const char *picture, \&.\&.\&.);

//  Receive a binary encoded \*(Aqpicture\*(Aq message from the socket (or actor)\&.
//  This method is similar to zsock_recv, except the arguments are encoded
//  in a binary format that is compatible with zproto, and is designed to
//  reduce memory allocations\&. The pattern argument is a string that defines
//  the type of each argument\&. See zsock_bsend for the supported argument
//  types\&. All arguments must be pointers; this call sets them to point to
//  values held on a per\-socket basis\&.
//  Note that zsock_brecv creates the returned objects, and the caller must
//  destroy them when finished with them\&. The supplied pointers do not need
//  to be initialized\&. Returns 0 if successful, or \-1 if it failed to read
//  a message\&.
CZMQ_EXPORT int
    zsock_brecv (void *self, const char *picture, \&.\&.\&.);

//  Set socket to use unbounded pipes (HWM=0); use this in cases when you are
//  totally certain the message volume can fit in memory\&. This method works
//  across all versions of ZeroMQ\&. Takes a polymorphic socket reference\&.
CZMQ_EXPORT void
    zsock_set_unbounded (void *self);

//  Send a signal over a socket\&. A signal is a short message carrying a
//  success/failure code (by convention, 0 means OK)\&. Signals are encoded
//  to be distinguishable from "normal" messages\&. Accepts a zsock_t or a
//  zactor_t argument, and returns 0 if successful, \-1 if the signal could
//  not be sent\&. Takes a polymorphic socket reference\&.
CZMQ_EXPORT int
    zsock_signal (void *self, byte status);

//  Wait on a signal\&. Use this to coordinate between threads, over pipe
//  pairs\&. Blocks until the signal is received\&. Returns \-1 on error, 0 or
//  greater on success\&. Accepts a zsock_t or a zactor_t as argument\&.
//  Takes a polymorphic socket reference\&.
CZMQ_EXPORT int
    zsock_wait (void *self);

//  If there is a partial message still waiting on the socket, remove and
//  discard it\&. This is useful when reading partial messages, to get specific
//  message types\&.
CZMQ_EXPORT void
    zsock_flush (void *self);

//  Probe the supplied object, and report if it looks like a zsock_t\&.
//  Takes a polymorphic socket reference\&.
CZMQ_EXPORT bool
    zsock_is (void *self);

//  Probe the supplied reference\&. If it looks like a zsock_t instance, return
//  the underlying libzmq socket handle; else if it looks like a file
//  descriptor, return NULL; else if it looks like a libzmq socket handle,
//  return the supplied value\&. Takes a polymorphic socket reference\&.
CZMQ_EXPORT void *
    zsock_resolve (void *self);

//  Get socket option `heartbeat_ivl`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_heartbeat_ivl (void *self);

//  Set socket option `heartbeat_ivl`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_heartbeat_ivl (void *self, int heartbeat_ivl);

//  Get socket option `heartbeat_ttl`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_heartbeat_ttl (void *self);

//  Set socket option `heartbeat_ttl`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_heartbeat_ttl (void *self, int heartbeat_ttl);

//  Get socket option `heartbeat_timeout`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_heartbeat_timeout (void *self);

//  Set socket option `heartbeat_timeout`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_heartbeat_timeout (void *self, int heartbeat_timeout);

//  Get socket option `use_fd`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_use_fd (void *self);

//  Set socket option `use_fd`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_use_fd (void *self, int use_fd);

//  Set socket option `xpub_manual`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_xpub_manual (void *self, int xpub_manual);

//  Set socket option `xpub_welcome_msg`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_xpub_welcome_msg (void *self, const char *xpub_welcome_msg);

//  Set socket option `stream_notify`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_stream_notify (void *self, int stream_notify);

//  Get socket option `invert_matching`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_invert_matching (void *self);

//  Set socket option `invert_matching`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_invert_matching (void *self, int invert_matching);

//  Set socket option `xpub_verboser`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_xpub_verboser (void *self, int xpub_verboser);

//  Get socket option `connect_timeout`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_connect_timeout (void *self);

//  Set socket option `connect_timeout`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_connect_timeout (void *self, int connect_timeout);

//  Get socket option `tcp_maxrt`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_tcp_maxrt (void *self);

//  Set socket option `tcp_maxrt`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_tcp_maxrt (void *self, int tcp_maxrt);

//  Get socket option `thread_safe`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_thread_safe (void *self);

//  Get socket option `multicast_maxtpdu`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_multicast_maxtpdu (void *self);

//  Set socket option `multicast_maxtpdu`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_multicast_maxtpdu (void *self, int multicast_maxtpdu);

//  Get socket option `vmci_buffer_size`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_vmci_buffer_size (void *self);

//  Set socket option `vmci_buffer_size`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_vmci_buffer_size (void *self, int vmci_buffer_size);

//  Get socket option `vmci_buffer_min_size`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_vmci_buffer_min_size (void *self);

//  Set socket option `vmci_buffer_min_size`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_vmci_buffer_min_size (void *self, int vmci_buffer_min_size);

//  Get socket option `vmci_buffer_max_size`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_vmci_buffer_max_size (void *self);

//  Set socket option `vmci_buffer_max_size`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_vmci_buffer_max_size (void *self, int vmci_buffer_max_size);

//  Get socket option `vmci_connect_timeout`\&.
//  Available from libzmq 4\&.2\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_vmci_connect_timeout (void *self);

//  Set socket option `vmci_connect_timeout`\&.
//  Available from libzmq 4\&.2\&.0\&.
CZMQ_EXPORT void
    zsock_set_vmci_connect_timeout (void *self, int vmci_connect_timeout);

//  Get socket option `tos`\&.
//  Available from libzmq 4\&.1\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_tos (void *self);

//  Set socket option `tos`\&.
//  Available from libzmq 4\&.1\&.0\&.
CZMQ_EXPORT void
    zsock_set_tos (void *self, int tos);

//  Set socket option `router_handover`\&.
//  Available from libzmq 4\&.1\&.0\&.
CZMQ_EXPORT void
    zsock_set_router_handover (void *self, int router_handover);

//  Set socket option `connect_rid`\&.
//  Available from libzmq 4\&.1\&.0\&.
CZMQ_EXPORT void
    zsock_set_connect_rid (void *self, const char *connect_rid);

//  Set socket option `connect_rid` from 32\-octet binary
//  Available from libzmq 4\&.1\&.0\&.
CZMQ_EXPORT void
    zsock_set_connect_rid_bin (void *self, const byte *connect_rid);

//  Get socket option `handshake_ivl`\&.
//  Available from libzmq 4\&.1\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_handshake_ivl (void *self);

//  Set socket option `handshake_ivl`\&.
//  Available from libzmq 4\&.1\&.0\&.
CZMQ_EXPORT void
    zsock_set_handshake_ivl (void *self, int handshake_ivl);

//  Get socket option `socks_proxy`\&.
//  Available from libzmq 4\&.1\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_socks_proxy (void *self);

//  Set socket option `socks_proxy`\&.
//  Available from libzmq 4\&.1\&.0\&.
CZMQ_EXPORT void
    zsock_set_socks_proxy (void *self, const char *socks_proxy);

//  Set socket option `xpub_nodrop`\&.
//  Available from libzmq 4\&.1\&.0\&.
CZMQ_EXPORT void
    zsock_set_xpub_nodrop (void *self, int xpub_nodrop);

//  Set socket option `router_mandatory`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_router_mandatory (void *self, int router_mandatory);

//  Set socket option `probe_router`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_probe_router (void *self, int probe_router);

//  Set socket option `req_relaxed`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_req_relaxed (void *self, int req_relaxed);

//  Set socket option `req_correlate`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_req_correlate (void *self, int req_correlate);

//  Set socket option `conflate`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_conflate (void *self, int conflate);

//  Get socket option `zap_domain`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_zap_domain (void *self);

//  Set socket option `zap_domain`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_zap_domain (void *self, const char *zap_domain);

//  Get socket option `mechanism`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_mechanism (void *self);

//  Get socket option `plain_server`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_plain_server (void *self);

//  Set socket option `plain_server`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_plain_server (void *self, int plain_server);

//  Get socket option `plain_username`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_plain_username (void *self);

//  Set socket option `plain_username`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_plain_username (void *self, const char *plain_username);

//  Get socket option `plain_password`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_plain_password (void *self);

//  Set socket option `plain_password`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_plain_password (void *self, const char *plain_password);

//  Get socket option `curve_server`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_curve_server (void *self);

//  Set socket option `curve_server`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_curve_server (void *self, int curve_server);

//  Get socket option `curve_publickey`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_curve_publickey (void *self);

//  Set socket option `curve_publickey`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_curve_publickey (void *self, const char *curve_publickey);

//  Set socket option `curve_publickey` from 32\-octet binary
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_curve_publickey_bin (void *self, const byte *curve_publickey);

//  Get socket option `curve_secretkey`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_curve_secretkey (void *self);

//  Set socket option `curve_secretkey`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_curve_secretkey (void *self, const char *curve_secretkey);

//  Set socket option `curve_secretkey` from 32\-octet binary
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_curve_secretkey_bin (void *self, const byte *curve_secretkey);

//  Get socket option `curve_serverkey`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_curve_serverkey (void *self);

//  Set socket option `curve_serverkey`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_curve_serverkey (void *self, const char *curve_serverkey);

//  Set socket option `curve_serverkey` from 32\-octet binary
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_curve_serverkey_bin (void *self, const byte *curve_serverkey);

//  Get socket option `gssapi_server`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_gssapi_server (void *self);

//  Set socket option `gssapi_server`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_gssapi_server (void *self, int gssapi_server);

//  Get socket option `gssapi_plaintext`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_gssapi_plaintext (void *self);

//  Set socket option `gssapi_plaintext`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_gssapi_plaintext (void *self, int gssapi_plaintext);

//  Get socket option `gssapi_principal`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_gssapi_principal (void *self);

//  Set socket option `gssapi_principal`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_gssapi_principal (void *self, const char *gssapi_principal);

//  Get socket option `gssapi_service_principal`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_gssapi_service_principal (void *self);

//  Set socket option `gssapi_service_principal`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_gssapi_service_principal (void *self, const char *gssapi_service_principal);

//  Get socket option `ipv6`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_ipv6 (void *self);

//  Set socket option `ipv6`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_ipv6 (void *self, int ipv6);

//  Get socket option `immediate`\&.
//  Available from libzmq 4\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_immediate (void *self);

//  Set socket option `immediate`\&.
//  Available from libzmq 4\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_immediate (void *self, int immediate);

//  Get socket option `type`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_type (void *self);

//  Get socket option `sndhwm`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_sndhwm (void *self);

//  Set socket option `sndhwm`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_sndhwm (void *self, int sndhwm);

//  Get socket option `rcvhwm`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_rcvhwm (void *self);

//  Set socket option `rcvhwm`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_rcvhwm (void *self, int rcvhwm);

//  Get socket option `affinity`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_affinity (void *self);

//  Set socket option `affinity`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_affinity (void *self, int affinity);

//  Set socket option `subscribe`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_subscribe (void *self, const char *subscribe);

//  Set socket option `unsubscribe`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_unsubscribe (void *self, const char *unsubscribe);

//  Get socket option `identity`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_identity (void *self);

//  Set socket option `identity`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_identity (void *self, const char *identity);

//  Get socket option `rate`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_rate (void *self);

//  Set socket option `rate`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_rate (void *self, int rate);

//  Get socket option `recovery_ivl`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_recovery_ivl (void *self);

//  Set socket option `recovery_ivl`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_recovery_ivl (void *self, int recovery_ivl);

//  Get socket option `sndbuf`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_sndbuf (void *self);

//  Set socket option `sndbuf`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_sndbuf (void *self, int sndbuf);

//  Get socket option `rcvbuf`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_rcvbuf (void *self);

//  Set socket option `rcvbuf`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_rcvbuf (void *self, int rcvbuf);

//  Get socket option `linger`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_linger (void *self);

//  Set socket option `linger`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_linger (void *self, int linger);

//  Get socket option `reconnect_ivl`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_reconnect_ivl (void *self);

//  Set socket option `reconnect_ivl`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_reconnect_ivl (void *self, int reconnect_ivl);

//  Get socket option `reconnect_ivl_max`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_reconnect_ivl_max (void *self);

//  Set socket option `reconnect_ivl_max`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_reconnect_ivl_max (void *self, int reconnect_ivl_max);

//  Get socket option `backlog`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_backlog (void *self);

//  Set socket option `backlog`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_backlog (void *self, int backlog);

//  Get socket option `maxmsgsize`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_maxmsgsize (void *self);

//  Set socket option `maxmsgsize`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_maxmsgsize (void *self, int maxmsgsize);

//  Get socket option `multicast_hops`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_multicast_hops (void *self);

//  Set socket option `multicast_hops`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_multicast_hops (void *self, int multicast_hops);

//  Get socket option `rcvtimeo`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_rcvtimeo (void *self);

//  Set socket option `rcvtimeo`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_rcvtimeo (void *self, int rcvtimeo);

//  Get socket option `sndtimeo`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_sndtimeo (void *self);

//  Set socket option `sndtimeo`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_sndtimeo (void *self, int sndtimeo);

//  Set socket option `xpub_verbose`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_xpub_verbose (void *self, int xpub_verbose);

//  Get socket option `tcp_keepalive`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_tcp_keepalive (void *self);

//  Set socket option `tcp_keepalive`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_tcp_keepalive (void *self, int tcp_keepalive);

//  Get socket option `tcp_keepalive_idle`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_tcp_keepalive_idle (void *self);

//  Set socket option `tcp_keepalive_idle`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_tcp_keepalive_idle (void *self, int tcp_keepalive_idle);

//  Get socket option `tcp_keepalive_cnt`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_tcp_keepalive_cnt (void *self);

//  Set socket option `tcp_keepalive_cnt`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_tcp_keepalive_cnt (void *self, int tcp_keepalive_cnt);

//  Get socket option `tcp_keepalive_intvl`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_tcp_keepalive_intvl (void *self);

//  Set socket option `tcp_keepalive_intvl`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_tcp_keepalive_intvl (void *self, int tcp_keepalive_intvl);

//  Get socket option `tcp_accept_filter`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_tcp_accept_filter (void *self);

//  Set socket option `tcp_accept_filter`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_tcp_accept_filter (void *self, const char *tcp_accept_filter);

//  Get socket option `rcvmore`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_rcvmore (void *self);

//  Get socket option `fd`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT SOCKET
    zsock_fd (void *self);

//  Get socket option `events`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_events (void *self);

//  Get socket option `last_endpoint`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT char *
    zsock_last_endpoint (void *self);

//  Set socket option `router_raw`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_router_raw (void *self, int router_raw);

//  Get socket option `ipv4only`\&.
//  Available from libzmq 3\&.0\&.0\&.
//  Caller owns return value and must destroy it when done\&.
CZMQ_EXPORT int
    zsock_ipv4only (void *self);

//  Set socket option `ipv4only`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_ipv4only (void *self, int ipv4only);

//  Set socket option `delay_attach_on_connect`\&.
//  Available from libzmq 3\&.0\&.0\&.
CZMQ_EXPORT void
    zsock_set_delay_attach_on_connect (void *self, int delay_attach_on_connect);

//  Self test of this class\&.
CZMQ_EXPORT void
    zsock_test (bool verbose);

#ifdef CZMQ_BUILD_DRAFT_API
//  *** Draft method, for development use, may change without warning ***
//  Create a SERVER socket\&. Default action is bind\&.
CZMQ_EXPORT zsock_t *
    zsock_new_server (const char *endpoint);

//  *** Draft method, for development use, may change without warning ***
//  Create a CLIENT socket\&. Default action is connect\&.
CZMQ_EXPORT zsock_t *
    zsock_new_client (const char *endpoint);

//  *** Draft method, for development use, may change without warning ***
//  Create a RADIO socket\&. Default action is bind\&.
CZMQ_EXPORT zsock_t *
    zsock_new_radio (const char *endpoint);

//  *** Draft method, for development use, may change without warning ***
//  Create a DISH socket\&. Default action is connect\&.
CZMQ_EXPORT zsock_t *
    zsock_new_dish (const char *endpoint);

//  *** Draft method, for development use, may change without warning ***
//  Create a GATHER socket\&. Default action is bind\&.
CZMQ_EXPORT zsock_t *
    zsock_new_gather (const char *endpoint);

//  *** Draft method, for development use, may change without warning ***
//  Create a SCATTER socket\&. Default action is connect\&.
CZMQ_EXPORT zsock_t *
    zsock_new_scatter (const char *endpoint);

//  *** Draft method, for development use, may change without warning ***
//  Return socket routing ID if any\&. This returns 0 if the socket is not
//  of type ZMQ_SERVER or if no request was already received on it\&.
CZMQ_EXPORT uint32_t
    zsock_routing_id (zsock_t *self);

//  *** Draft method, for development use, may change without warning ***
//  Set routing ID on socket\&. The socket MUST be of type ZMQ_SERVER\&.
//  This will be used when sending messages on the socket via the zsock API\&.
CZMQ_EXPORT void
    zsock_set_routing_id (zsock_t *self, uint32_t routing_id);

//  *** Draft method, for development use, may change without warning ***
//  Join a group for the RADIO\-DISH pattern\&. Call only on ZMQ_DISH\&.
//  Returns 0 if OK, \-1 if failed\&.
CZMQ_EXPORT int
    zsock_join (void *self, const char *group);

//  *** Draft method, for development use, may change without warning ***
//  Leave a group for the RADIO\-DISH pattern\&. Call only on ZMQ_DISH\&.
//  Returns 0 if OK, \-1 if failed\&.
CZMQ_EXPORT int
    zsock_leave (void *self, const char *group);

#endif // CZMQ_BUILD_DRAFT_API
Please add \*(Aq@interface\*(Aq section in \*(Aq\&./\&.\&./src/zsock\&.c\*(Aq\&.
.fi
.SH "DESCRIPTION"
.sp
The zsock class wraps the libzmq socket handle (a void *) with a proper structure that follows the CLASS rules for construction and destruction\&. Some zsock methods take a void * "polymorphic" reference, which can be either a zsock_t or a zactor_t reference, or a libzmq void *\&.
.sp
Please add \fI@discuss\fR section in \fI\&./\&.\&./src/zsock\&.c\fR\&.
.SH "EXAMPLE"
.PP
\fBFrom zsock_test method\fR. 
.sp
.if n \{\
.RS 4
.\}
.nf
zsock_t *writer = zsock_new_push ("@tcp://127\&.0\&.0\&.1:5560");
assert (writer);
assert (zsock_resolve (writer) != writer);
assert (streq (zsock_type_str (writer), "PUSH"));

int rc;
#if (ZMQ_VERSION >= ZMQ_MAKE_VERSION (3, 2, 0))
//  Check unbind
rc = zsock_unbind (writer, "tcp://127\&.0\&.0\&.1:%d", 5560);
assert (rc == 0);

//  In some cases and especially when running under Valgrind, doing
//  a bind immediately after an unbind causes an EADDRINUSE error\&.
//  Even a short sleep allows the OS to release the port for reuse\&.
zclock_sleep (100);

//  Bind again
rc = zsock_bind (writer, "tcp://127\&.0\&.0\&.1:%d", 5560);
assert (rc == 5560);
assert (streq (zsock_endpoint (writer), "tcp://127\&.0\&.0\&.1:5560"));
#endif

zsock_t *reader = zsock_new_pull (">tcp://127\&.0\&.0\&.1:5560");
assert (reader);
assert (zsock_resolve (reader) != reader);
assert (streq (zsock_type_str (reader), "PULL"));

//  Basic Hello, World
zstr_send (writer, "Hello, World");
zmsg_t *msg = zmsg_recv (reader);
assert (msg);
char *string = zmsg_popstr (msg);
assert (streq (string, "Hello, World"));
free (string);
zmsg_destroy (&msg);

//  Test resolve libzmq socket
#if (ZMQ_VERSION >= ZMQ_MAKE_VERSION (3, 2, 0))
void *zmq_ctx = zmq_ctx_new ();
#else
void *zmq_ctx = zmq_ctx_new (1);
#endif
assert (zmq_ctx);
void *zmq_sock = zmq_socket (zmq_ctx, ZMQ_PUB);
assert (zmq_sock);
assert (zsock_resolve (zmq_sock) == zmq_sock);
zmq_close (zmq_sock);
zmq_ctx_term (zmq_ctx);

//  Test resolve zsock
zsock_t *resolve = zsock_new_pub("@tcp://127\&.0\&.0\&.1:5561");
assert (resolve);
assert (zsock_resolve (resolve) == resolve\->handle);
zsock_destroy (&resolve);

//  Test resolve FD
SOCKET fd = zsock_fd (reader);
assert (zsock_resolve ((void *) &fd) == NULL);

//  Test binding to ephemeral ports, sequential and random
int port = zsock_bind (writer, "tcp://127\&.0\&.0\&.1:*");
assert (port >= DYNAMIC_FIRST && port <= DYNAMIC_LAST);
port = zsock_bind (writer, "tcp://127\&.0\&.0\&.1:*[50000\-]");
assert (port >= 50000 && port <= DYNAMIC_LAST);
port = zsock_bind (writer, "tcp://127\&.0\&.0\&.1:*[\-50001]");
assert (port >= DYNAMIC_FIRST && port <= 50001);
port = zsock_bind (writer, "tcp://127\&.0\&.0\&.1:*[60000\-60050]");
assert (port >= 60000 && port <= 60050);

port = zsock_bind (writer, "tcp://127\&.0\&.0\&.1:!");
assert (port >= DYNAMIC_FIRST && port <= DYNAMIC_LAST);
port = zsock_bind (writer, "tcp://127\&.0\&.0\&.1:![50000\-]");
assert (port >= 50000 && port <= DYNAMIC_LAST);
port = zsock_bind (writer, "tcp://127\&.0\&.0\&.1:![\-50001]");
assert (port >= DYNAMIC_FIRST && port <= 50001);
port = zsock_bind (writer, "tcp://127\&.0\&.0\&.1:![60000\-60050]");
assert (port >= 60000 && port <= 60050);

//  Test zsock_attach method
zsock_t *server = zsock_new (ZMQ_DEALER);
assert (server);
rc = zsock_attach (server, "@inproc://myendpoint,tcp://127\&.0\&.0\&.1:5556,inproc://others", true);
assert (rc == 0);
rc = zsock_attach (server, "", false);
assert (rc == 0);
rc = zsock_attach (server, NULL, true);
assert (rc == 0);
rc = zsock_attach (server, ">a,@b, c,, ", false);
assert (rc == \-1);
zsock_destroy (&server);

//  Test zsock_endpoint method
rc = zsock_bind (writer, "inproc://test\&.%s", "writer");
assert (rc == 0);
assert (streq (zsock_endpoint (writer), "inproc://test\&.writer"));

//  Test error state when connecting to an invalid socket type
//  (\*(Aqtxp://\*(Aq instead of \*(Aqtcp://\*(Aq, typo intentional)
rc = zsock_connect (reader, "txp://127\&.0\&.0\&.1:5560");
assert (rc == \-1);

//  Test signal/wait methods
rc = zsock_signal (writer, 123);
assert (rc == 0);
rc = zsock_wait (reader);
assert (rc == 123);

//  Test zsock_send/recv pictures
uint8_t  number1 = 123;
uint16_t number2 = 123 * 123;
uint32_t number4 = 123 * 123;
number4 *= 123;
uint32_t number4_MAX = UINT32_MAX;
uint64_t number8 = 123 * 123;
number8 *= 123;
number8 *= 123;
uint64_t number8_MAX = UINT64_MAX;

zchunk_t *chunk = zchunk_new ("HELLO", 5);
assert (chunk);
zframe_t *frame = zframe_new ("WORLD", 5);
assert (frame);
zhashx_t *hash = zhashx_new ();
assert (hash);
zuuid_t *uuid = zuuid_new ();
assert (uuid);
zhashx_set_destructor (hash, (zhashx_destructor_fn *) zstr_free);
zhashx_set_duplicator (hash, (zhashx_duplicator_fn *) strdup);
zhashx_insert (hash, "1", "value A");
zhashx_insert (hash, "2", "value B");
char *original = "pointer";

//  Test zsock_recv into each supported type
zsock_send (writer, "i124488zsbcfUhp",
            \-12345, number1, number2, number4, number4_MAX,
            number8, number8_MAX,
            "This is a string", "ABCDE", 5,
            chunk, frame, uuid, hash, original);
char *uuid_str = strdup (zuuid_str (uuid));
zchunk_destroy (&chunk);
zframe_destroy (&frame);
zuuid_destroy (&uuid);
zhashx_destroy (&hash);

int integer;
byte *data;
size_t size;
char *pointer;
number8_MAX = number8 = number4_MAX = number4 = number2 = number1 = 0ULL;
rc = zsock_recv (reader, "i124488zsbcfUhp",
                 &integer, &number1, &number2, &number4, &number4_MAX,
                 &number8, &number8_MAX, &string, &data, &size, &chunk,
                 &frame, &uuid, &hash, &pointer);
assert (rc == 0);
assert (integer == \-12345);
assert (number1 == 123);
assert (number2 == 123 * 123);
assert (number4 == 123 * 123 * 123);
assert (number4_MAX == UINT32_MAX);
assert (number8 == 123 * 123 * 123 * 123);
assert (number8_MAX == UINT64_MAX);
assert (streq (string, "This is a string"));
assert (memcmp (data, "ABCDE", 5) == 0);
assert (size == 5);
assert (memcmp (zchunk_data (chunk), "HELLO", 5) == 0);
assert (zchunk_size (chunk) == 5);
assert (streq (uuid_str, zuuid_str (uuid)));
assert (memcmp (zframe_data (frame), "WORLD", 5) == 0);
assert (zframe_size (frame) == 5);
char *value = (char *) zhashx_lookup (hash, "1");
assert (streq (value, "value A"));
value = (char *) zhashx_lookup (hash, "2");
assert (streq (value, "value B"));
assert (original == pointer);
free (string);
free (data);
free (uuid_str);
zframe_destroy (&frame);
zchunk_destroy (&chunk);
zhashx_destroy (&hash);
zuuid_destroy (&uuid);

//  Test zsock_recv of short message; this lets us return a failure
//  with a status code and then nothing else; the receiver will get
//  the status code and NULL/zero for all other values
zsock_send (writer, "i", \-1);
zsock_recv (reader, "izsbcfp",
    &integer, &string, &data, &size, &chunk, &frame, &pointer);
assert (integer == \-1);
assert (string == NULL);
assert (data == NULL);
assert (size == 0);
assert (chunk == NULL);
assert (frame == NULL);
assert (pointer == NULL);

msg = zmsg_new ();
zmsg_addstr (msg, "frame 1");
zmsg_addstr (msg, "frame 2");
zsock_send (writer, "szm", "header", msg);
zmsg_destroy (&msg);

zsock_recv (reader, "szm", &string, &msg);

assert (streq ("header", string));
assert (zmsg_size (msg) == 2);
assert (zframe_streq (zmsg_first (msg), "frame 1"));
assert (zframe_streq (zmsg_next (msg), "frame 2"));
zstr_free (&string);
zmsg_destroy (&msg);

//  Test zsock_recv with null arguments
chunk = zchunk_new ("HELLO", 5);
assert (chunk);
frame = zframe_new ("WORLD", 5);
assert (frame);
zsock_send (writer, "izsbcfp",
            \-12345, "This is a string", "ABCDE", 5, chunk, frame, original);
zframe_destroy (&frame);
zchunk_destroy (&chunk);
zsock_recv (reader, "izsbcfp", &integer, NULL, NULL, NULL, &chunk, NULL, NULL);
assert (integer == \-12345);
assert (memcmp (zchunk_data (chunk), "HELLO", 5) == 0);
assert (zchunk_size (chunk) == 5);
zchunk_destroy (&chunk);

//  Test zsock_bsend/brecv pictures with binary encoding
frame = zframe_new ("Hello", 5);
chunk = zchunk_new ("World", 5);

msg = zmsg_new ();
zmsg_addstr (msg, "Hello");
zmsg_addstr (msg, "World");

zsock_bsend (writer, "1248sSpcfm",
             number1, number2, number4, number8,
             "Hello, World",
             "Goodbye cruel World!",
             original,
             chunk, frame, msg);
zchunk_destroy (&chunk);
zframe_destroy (&frame);
zmsg_destroy (&msg);

number8 = number4 = number2 = number1 = 0;
char *longstr;
zsock_brecv (reader, "1248sSpcfm",
             &number1, &number2, &number4, &number8,
             &string, &longstr,
             &pointer,
             &chunk, &frame, &msg);
assert (number1 == 123);
assert (number2 == 123 * 123);
assert (number4 == 123 * 123 * 123);
assert (number8 == 123 * 123 * 123 * 123);
assert (streq (string, "Hello, World"));
assert (streq (longstr, "Goodbye cruel World!"));
assert (pointer == original);
zstr_free (&longstr);
zchunk_destroy (&chunk);
zframe_destroy (&frame);
zmsg_destroy (&msg);

#ifdef ZMQ_SERVER

//  Test zsock_bsend/brecv pictures with binary encoding on SERVER and CLIENT sockets
server = zsock_new_server ("tcp://127\&.0\&.0\&.1:5561");
assert (server);
zsock_t* client = zsock_new_client ("tcp://127\&.0\&.0\&.1:5561");
assert (client);

//  From client to server
chunk = zchunk_new ("World", 5);
zsock_bsend (client, "1248sSpc",
             number1, number2, number4, number8,
             "Hello, World",
             "Goodbye cruel World!",
             original,
             chunk);
zchunk_destroy (&chunk);

number8 = number4 = number2 = number1 = 0;
zsock_brecv (server, "1248sSpc",
             &number1, &number2, &number4, &number8,
             &string, &longstr,
             &pointer,
             &chunk);
assert (number1 == 123);
assert (number2 == 123 * 123);
assert (number4 == 123 * 123 * 123);
assert (number8 == 123 * 123 * 123 * 123);
assert (streq (string, "Hello, World"));
assert (streq (longstr, "Goodbye cruel World!"));
assert (pointer == original);
assert (zsock_routing_id (server));
zstr_free (&longstr);
zchunk_destroy (&chunk);

//  From server to client
chunk = zchunk_new ("World", 5);
zsock_bsend (server, "1248sSpc",
             number1, number2, number4, number8,
             "Hello, World",
             "Goodbye cruel World!",
             original,
             chunk);
zchunk_destroy (&chunk);

number8 = number4 = number2 = number1 = 0;
zsock_brecv (client, "1248sSpc",
             &number1, &number2, &number4, &number8,
             &string, &longstr,
             &pointer,
             &chunk);
assert (number1 == 123);
assert (number2 == 123 * 123);
assert (number4 == 123 * 123 * 123);
assert (number8 == 123 * 123 * 123 * 123);
assert (streq (string, "Hello, World"));
assert (streq (longstr, "Goodbye cruel World!"));
assert (pointer == original);
assert (zsock_routing_id (client) == 0);
zstr_free (&longstr);
zchunk_destroy (&chunk);

zsock_destroy (&client);
zsock_destroy (&server);

#endif

#ifdef ZMQ_SCATTER

zsock_t* gather = zsock_new_gather ("inproc://test\-gather\-scatter");
assert (gather);
zsock_t* scatter = zsock_new_scatter ("inproc://test\-gather\-scatter");
assert (scatter);

rc = zstr_send (scatter, "HELLO");
assert (rc == 0);

char* message;
message = zstr_recv (gather);
assert (streq(message, "HELLO"));
zstr_free (&message);

zsock_destroy (&gather);
zsock_destroy (&scatter);

#endif

//  Check that we can send a zproto format message
zsock_bsend (writer, "1111sS4", 0xAA, 0xA0, 0x02, 0x01, "key", "value", 1234);
zgossip_msg_t *gossip = zgossip_msg_new ();
zgossip_msg_recv (gossip, reader);
assert (zgossip_msg_id (gossip) == ZGOSSIP_MSG_PUBLISH);
zgossip_msg_destroy (&gossip);

zsock_destroy (&reader);
zsock_destroy (&writer);
.fi
.if n \{\
.RE
.\}
.sp
.SH "AUTHORS"
.sp
The czmq manual was written by the authors in the AUTHORS file\&.
.SH "RESOURCES"
.sp
Main web site: \m[blue]\fB\%\fR\m[]
.sp
Report bugs to the email <\m[blue]\fBzeromq\-dev@lists\&.zeromq\&.org\fR\m[]\&\s-2\u[1]\d\s+2>
.SH "COPYRIGHT"
.sp
Copyright (c) the Contributors as noted in the AUTHORS file\&. This file is part of CZMQ, the high\-level C binding for 0MQ: http://czmq\&.zeromq\&.org\&. This Source Code Form is subject to the terms of the Mozilla Public License, v\&. 2\&.0\&. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla\&.org/MPL/2\&.0/\&. LICENSE included with the czmq distribution\&.
.SH "NOTES"
.IP " 1." 4
zeromq-dev@lists.zeromq.org
.RS 4
\%mailto:zeromq-dev@lists.zeromq.org
.RE
